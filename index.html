<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>XR Letter + Progress Showcase</title>

    <!-- Zen Kurenaido -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Kurenaido&display=swap" rel="stylesheet">

    <!-- A-Frame / AR.js -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="./js/aframe-ar.js?v=1.0.2"></script>

    <!-- キャッシュ対策 -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .overlay {
        position: fixed;
        z-index: 9998;
        top: 0;
        left: 0;
        width: 100%;
        pointer-events: none; /* 中身だけクリック可能にする */
        font-family: 'Zen Kurenaido', system-ui, sans-serif;
      }
      .menu-bar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        color: #ffffff;
        pointer-events: auto;
      }
      .hamburger {
        width: 28px;
        height: 24px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        cursor: pointer;
      }
      .hamburger span {
        display: block;
        height: 3px;
        background: #ffffff;
        border-radius: 999px;
      }
      .menu-title {
        font-size: 14px;
      }

      .menu-panel {
        position: absolute;
        top: 40px;
        left: 10px;
        background: rgba(0, 0, 0, 0.75);
        color: #ffffff;
        padding: 8px 4px;
        border-radius: 8px;
        min-width: 120px;
        display: none;
        pointer-events: auto;
        z-index: 9999;
      }
      .menu-item {
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
      }
      .menu-item:hover {
        background: rgba(255, 255, 255, 0.12);
      }
      .menu-item.active {
        background: rgba(255, 255, 255, 0.20);
      }

      .mode-indicator {
        position: absolute;
        bottom: 8px;
        left: 50%;
        transform: translateX(-50%);
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.4);
        color: #ffffff;
        pointer-events: none;
      }

      #touchLayer {
        position: fixed;
        z-index: 10;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
        background: transparent;
        pointer-events: none; /* ひとまず無効化。必要になったら progress のときだけ有効にしてもOK */
      }
    </style>

    <script>
      /********************************************
       * 進捗データ（★ここを編集するだけで追加できる）
       ********************************************/
      const PROGRESS_ITEMS = [
        {
          id: 'p1',
          modelPath: './models/sample1.glb',
          title: 'XR手紙のベース実装',
          date: '2025-11-19'
        },
        {
          id: 'p2',
          modelPath: './models/sample2.glb',
          title: 'エンドロール演出追加',
          date: '2025-11-20'
        },
        {
          id: 'p3',
          modelPath: './models/prism.obj',
          mtlPath: './models/prism.mtl',
          title: 'プリズムオブジェクト配置',
          date: '2025-11-21',
          scale: '0.25 0.25 0.25'
        }
      ];

      /********************************************
       * 進捗モデル生成ユーティリティ
       ********************************************/
      function parseScaleString(scaleStr) {
        if (!scaleStr || typeof scaleStr !== 'string') return [1,1,1];
        const parts = scaleStr.trim().split(/\s+/).map(v => {
          const num = parseFloat(v);
          return Number.isFinite(num) ? num : 1;
        });
        while (parts.length < 3) parts.push(1);
        return parts.slice(0,3);
      }
      function scaleArrayToString(arr) {
        return arr.slice(0,3).map(v => Number(v.toFixed(4))).join(' ');
      }
      function multiplyScaleString(baseScale, factor) {
        const parsed = parseScaleString(baseScale);
        const scaled = parsed.map(v => v * factor);
        return scaleArrayToString(scaled);
      }

      function createModelElement(item) {
        const path = item.modelPath || '';
        const ext  = path.split('.').pop().toLowerCase();
        let modelEl;
        if (ext === 'glb' || ext === 'gltf') {
          modelEl = document.createElement('a-gltf-model');
          modelEl.setAttribute('src', path);
        } else if (ext === 'obj' || ext === 'fbx') {
          modelEl = document.createElement('a-obj-model');
          modelEl.setAttribute('src', path);
          if (item.mtlPath) modelEl.setAttribute('mtl', item.mtlPath);
        } else {
          modelEl = document.createElement('a-box');
          modelEl.setAttribute('depth', '0.3');
          modelEl.setAttribute('height', '0.3');
          modelEl.setAttribute('width',  '0.3');
          modelEl.dataset.activeColor   = '#ff9933';
          modelEl.dataset.inactiveColor = '#cccccc';
          modelEl.setAttribute('color', modelEl.dataset.inactiveColor);
        }
        modelEl.setAttribute('shadow', 'cast: true; receive: false');
        return modelEl;
      }

      function createProgressModelWrapper(item) {
        const wrapper = document.createElement('a-entity');
        wrapper.classList.add('progress-model');
        wrapper.setAttribute('position', '0 0.35 0');

        const baseScale        = item.scale || '0.35 0.35 0.35';
        const normalizedScale  = scaleArrayToString(parseScaleString(baseScale));
        wrapper.dataset.baseScale = normalizedScale;
        wrapper.setAttribute('scale', normalizedScale);

        const modelEl = createModelElement(item);
        wrapper.appendChild(modelEl);
        return wrapper;
      }

      /********************************************
       * グローバル：モード切り替え
       ********************************************/
      let currentMode  = 'letter';
      let letterRoot   = null;
      let progressRoot = null;

      function updateModeVisibility() {
        const indicator = document.getElementById('modeIndicator');
        const menuItems = document.querySelectorAll('.menu-item');

        if (letterRoot)   letterRoot.setAttribute('visible', currentMode === 'letter');
        if (progressRoot) progressRoot.setAttribute('visible', currentMode === 'progress');

        if (indicator) {
          indicator.textContent =
            currentMode === 'letter' ? 'モード：手紙' : 'モード：進捗';
        }

        menuItems.forEach(item => {
          const mode = item.getAttribute('data-mode');
          item.classList.toggle('active', mode === currentMode);
        });
      }

      function setMode(mode) {
        currentMode = mode;
        updateModeVisibility();
      }

      /********************************************
       * 手紙エンドロール
       ********************************************/
      const firstLineText = '塩田さんへ';

      const scrollLines = [
        '同じ学科の後輩として、',
        '同じ班の後輩として、',
        'いつも活動できたことが嬉しかったです。',
        '',
        '塩田さんは、',
        '僕にとって憧れの人です。',
        '明るさにも、優しさにも、',
        '全てに惹かれています。',
        '',
        '塩田さんがXR班をつくったことで、',
        '僕はXRという世界に出会いました。',
        'XRに触れた日から、',
        '視界が一気に広がりました。',
        '',
        '今回の理工展で企画を担当できたのも、',
        '塩田さんがいたからです。',
        '',
        '来期は、もっと面白いものを作ります。',
        '胸を張って見せられるものを作ります。',
        '',
        'このAR手紙には、',
        'これからの僕の進捗を、',
        '3Dオブジェクトで追加していこうと思っています。',
        '',
        'よかったら、また覗きに来てください。',
        'その時、少しでも成長した僕を',
        '見せられますように。',
        '',
        '', '', ''
      ];

      const finalBlockLines = [
        '本当にありがとうございました。',
        '齋藤旦伍より'
      ];

      const WINDOW_MIN_Y = -0.6;
      const WINDOW_MAX_Y =  0.6;
      const SCROLL_SPEED = 0.18;
      const BASE_START_Y = -1.0;
      const LINE_GAP     = 0.22;

      let firstDone        = false;
      let canvasIdCounter  = 0;

      function createCanvasForText(text) {
        const assets = document.querySelector('a-assets');
        if (!assets) return null;

        const id     = `msgCanvas_${canvasIdCounter++}`;
        const canvas = document.createElement('canvas');
        canvas.id    = id;
        const width  = 2048;
        const height = 256;
        canvas.width  = width;
        canvas.height = height;

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, width, height);
        ctx.font         = "80px 'Zen Kurenaido', sans-serif";
        ctx.fillStyle    = '#000000';
        ctx.textAlign    = 'center';
        ctx.textBaseline = 'middle';

        if (text.trim() !== '') {
          ctx.fillText(text, width / 2, height / 2);
        }
        assets.appendChild(canvas);
        return { id, width, height };
      }

      AFRAME.registerComponent('firstline', {
        schema: {
          fadeIn:  { type: 'number', default: 1.0 },
          hold:    { type: 'number', default: 3.0 },
          fadeOut: { type: 'number', default: 1.0 }
        },
        init: function () { this.startTime = null; },
        tick: function (time, dt) {
          const el   = this.el;
          const data = this.data;
          if (this.startTime === null) this.startTime = time;

          const t     = (time - this.startTime) / 1000;
          const total = data.fadeIn + data.hold + data.fadeOut;
          let alpha   = 0;

          if (t < data.fadeIn) {
            alpha = t / data.fadeIn;
          } else if (t < data.fadeIn + data.hold) {
            alpha = 1;
          } else if (t < total) {
            const t2 = t - (data.fadeIn + data.hold);
            alpha = 1 - (t2 / data.fadeOut);
          } else {
            alpha = 0;
            if (el.parentNode) el.parentNode.removeChild(el);
            firstDone = true;
          }
          el.setAttribute('material', 'transparent', true);
          el.setAttribute('material', 'opacity', alpha);
        }
      });

      AFRAME.registerComponent('scrollline', {
        schema: {
          speed:  { type: 'number', default: SCROLL_SPEED },
          startY: { type: 'number', default: BASE_START_Y },
          endY:   { type: 'number', default: 1.4 }
        },
        init: function () {
          const el   = this.el;
          const data = this.data;
          const pos  = el.getAttribute('position') || {x:0, y:0, z:0};
          pos.y = data.startY;
          el.setAttribute('position', pos);
        },
        tick: function (time, dt) {
          const el   = this.el;
          const data = this.data;
          const deltaSec = dt / 1000;
          const pos = el.getAttribute('position');
          pos.y += data.speed * deltaSec;
          el.setAttribute('position', pos);
          const y = pos.y;

          if (y < WINDOW_MIN_Y || y > WINDOW_MAX_Y) {
            el.setAttribute('material', 'transparent', true);
            el.setAttribute('material', 'opacity', 0.0);
          } else {
            el.setAttribute('material', 'transparent', true);
            el.setAttribute('material', 'opacity', 1.0);
          }

          if (y > data.endY && el.parentNode) {
            el.parentNode.removeChild(el);
          }
        }
      });

      AFRAME.registerComponent('finalblock', {
        schema: {
          fadeIn:  { type: 'number', default: 1.0 },
          hold:    { type: 'number', default: 3.0 },
          fadeOut: { type: 'number', default: 1.5 }
        },
        init: function () { this.startTime = null; },
        tick: function (time, dt) {
          const el   = this.el;
          const data = this.data;
          if (this.startTime === null) this.startTime = time;

          const t     = (time - this.startTime) / 1000;
          const total = data.fadeIn + data.hold + data.fadeOut;
          let alpha   = 0;

          if (t < data.fadeIn) {
            alpha = t / data.fadeIn;
          } else if (t < data.fadeIn + data.hold) {
            alpha = 1;
          } else if (t < total) {
            const t2 = t - (data.fadeIn + data.hold);
            alpha = 1 - (t2 / data.fadeOut);
          } else {
            alpha = 0;
            if (el.parentNode) el.parentNode.removeChild(el);
          }
          el.setAttribute('material', 'transparent', true);
          el.setAttribute('material', 'opacity', alpha);
        }
      });

      AFRAME.registerComponent('scroll-manager', {
        init: function () {
          this.scrollBuilt    = false;
          this.finalScheduled = false;
          const letterRootEl  = document.getElementById('letterRoot');
          if (!letterRootEl) return;

          const tex = createCanvasForText(firstLineText);
          if (!tex) return;

          const plane = document.createElement('a-plane');
          plane.setAttribute('material', `src: #${tex.id}; transparent: true; side: double`);
          const planeWidth  = 2.2;
          const aspect      = tex.height / tex.width;
          const planeHeight = planeWidth * aspect;
          plane.setAttribute('width',  planeWidth);
          plane.setAttribute('height', planeHeight);
          plane.setAttribute('position', '0 0 0.12');
          plane.setAttribute('rotation', '0 0 0');
          plane.setAttribute('firstline', 'fadeIn: 1.0; hold: 3.0; fadeOut: 1.0');

          letterRootEl.appendChild(plane);
        },

        tick: function (time, dt) {
          if (!firstDone) return;
          if (!this.scrollBuilt) {
            this.buildScrollLines();
            this.scrollBuilt = true;
          }
          if (this.scrollBuilt && !this.finalScheduled) {
            this.scheduleFinalBlock();
            this.finalScheduled = true;
          }
        },

        buildScrollLines: function () {
          const letterRootEl = document.getElementById('letterRoot');
          if (!letterRootEl) return;

          for (let i = 0; i < scrollLines.length; i++) {
            const text = scrollLines[i];
            const tex  = createCanvasForText(text);
            if (!tex) continue;

            const plane = document.createElement('a-plane');
            plane.setAttribute('material', `src: #${tex.id}; transparent: true; side: double`);
            const planeWidth  = 2.2;
            const aspect      = tex.height / tex.width;
            const planeHeight = planeWidth * aspect;
            plane.setAttribute('width',  planeWidth);
            plane.setAttribute('height', planeHeight);
            plane.setAttribute('position', '0 0 0.12');
            plane.setAttribute('rotation', '0 0 0');

            const startY = BASE_START_Y - i * LINE_GAP;
            plane.setAttribute('scrollline',
              `speed: ${SCROLL_SPEED}; startY: ${startY}; endY: 1.4`);
            letterRootEl.appendChild(plane);
          }
        },

        scheduleFinalBlock: function () {
          const lastIndex  = scrollLines.length - 1;
          const lastStartY = BASE_START_Y - lastIndex * LINE_GAP;
          const dist       = WINDOW_MAX_Y - lastStartY;
          const scrollTime = dist / SCROLL_SPEED;
          const margin     = 2.0;
          const delayMs    = (scrollTime + margin) * 1000;

          setTimeout(() => {
            const assets      = document.querySelector('a-assets');
            const letterRootEl = document.getElementById('letterRoot');
            if (!assets || !letterRootEl) return;

            const id     = 'finalCanvas';
            const canvas = document.createElement('canvas');
            canvas.id    = id;
            const width  = 2048;
            const height = 512;
            canvas.width  = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, width, height);
            ctx.font         = "80px 'Zen Kurenaido', sans-serif";
            ctx.fillStyle    = '#000000';
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(finalBlockLines[0], width / 2, height / 2 - 60);
            ctx.fillText(finalBlockLines[1], width / 2, height / 2 + 60);
            assets.appendChild(canvas);

            const plane = document.createElement('a-plane');
            plane.setAttribute('material', `src: #${id}; transparent: true; side: double`);
            const planeWidth  = 2.2;
            const aspect      = height / width;
            const planeHeight = planeWidth * aspect;
            plane.setAttribute('width',  planeWidth);
            plane.setAttribute('height', planeHeight);
            plane.setAttribute('position', '0 0 0.13');
            plane.setAttribute('rotation', '0 0 0');
            plane.setAttribute('finalblock', 'fadeIn: 1.0; hold: 3.0; fadeOut: 1.5');
            letterRootEl.appendChild(plane);
          }, delayMs);
        }
      });

      /********************************************
       * 進捗ショーケース
       ********************************************/
      AFRAME.registerComponent('progress-showcase', {
        init: function () {
          this.items       = PROGRESS_ITEMS;
          this.entities    = [];
          this.activeIndex = this.items.length - 1;

          this.buildShowcase();
          this.updateLayout();
        },

        buildShowcase: function () {
          const root = this.el;

          this.items.forEach(item => {
            const e       = document.createElement('a-entity');
            const wrapper = createProgressModelWrapper(item);
            e.appendChild(wrapper);
            root.appendChild(e);
            this.entities.push(e);
          });

          const title = document.createElement('a-text');
          title.setAttribute('id', 'progressTitle');
          title.setAttribute('value', '');
          title.setAttribute('color', '#000000');
          title.setAttribute('align', 'center');
          title.setAttribute('width', '2.4');
          title.setAttribute('position', '0 -0.15 0.15');
          this.titleEl = title;
          root.appendChild(title);

          const date = document.createElement('a-text');
          date.setAttribute('id', 'progressDate');
          date.setAttribute('value', '');
          date.setAttribute('color', '#333333');
          date.setAttribute('align', 'center');
          date.setAttribute('width', '2.4');
          date.setAttribute('position', '0 -0.32 0.15');
          this.dateEl = date;
          root.appendChild(date);
        },

        updateLayout: function () {
          const centerIndex = this.activeIndex;
          const offsetX     = 0.55;

          this.entities.forEach((e, i) => {
            const offset = i - centerIndex;
            e.setAttribute('position', `${offset * offsetX} 0 0.15`);

            const wrapper   = e.querySelector('.progress-model');
            if (!wrapper) return;
            const baseScale = wrapper.dataset.baseScale || '1 1 1';
            const factor    = i === centerIndex ? 1.25 : 0.85;
            wrapper.setAttribute('scale', multiplyScaleString(baseScale, factor));

            const child = wrapper.firstElementChild;
            if (child && child.tagName === 'A-BOX') {
              const activeColor   = child.dataset.activeColor   || '#ff9933';
              const inactiveColor = child.dataset.inactiveColor || '#cccccc';
              child.setAttribute('color', i === centerIndex ? activeColor : inactiveColor);
            }
          });

          const item = this.items[centerIndex];
          if (this.titleEl && this.dateEl && item) {
            this.titleEl.setAttribute('value', item.title);
            this.dateEl.setAttribute('value', item.date);
          }
        },

        next: function () {
          if (this.items.length === 0) return;
          this.activeIndex = Math.max(0, this.activeIndex - 1);
          this.updateLayout();
        },

        prev: function () {
          if (this.items.length === 0) return;
          this.activeIndex = Math.min(this.items.length - 1, this.activeIndex + 1);
          this.updateLayout();
        },

        tick: function (time, dt) {
          const centerIndex  = this.activeIndex;
          const centerEntity = this.entities[centerIndex];
          if (!centerEntity) return;
          const wrapper = centerEntity.querySelector('.progress-model');
          if (!wrapper) return;
          const rot = wrapper.getAttribute('rotation') || {x:0, y:0, z:0};
          rot.y += 30 * (dt / 1000);
          wrapper.setAttribute('rotation', rot);
        }
      });

      /********************************************
       * DOM 準備：一か所に集約
       ********************************************/
      document.addEventListener('DOMContentLoaded', () => {
        // A-Frameエンティティ参照
        letterRoot   = document.getElementById('letterRoot');
        progressRoot = document.getElementById('progressRoot');

        // 初期モード反映
        updateModeVisibility();

        // ハンバーガーメニュー
        const btn    = document.getElementById('menuButton');
        const panel  = document.getElementById('menuPanel');

        if (btn && panel) {
          btn.addEventListener('click', () => {
            const visible = panel.style.display === 'block';
            panel.style.display = visible ? 'none' : 'block';
          });

          panel.addEventListener('click', (e) => {
            const item = e.target.closest('.menu-item');
            if (!item) return;
            const mode = item.getAttribute('data-mode');
            setMode(mode);
            panel.style.display = 'none';
          });
        }

        // スワイプ（今は pointer-events: none なので無効状態。必要ならここで on/off 切り替え可）
        const touchLayer = document.getElementById('touchLayer');
        let touchStartX = null;

        if (touchLayer) {
          touchLayer.addEventListener('touchstart', (e) => {
            if (currentMode !== 'progress') return;
            if (e.touches.length > 0) {
              touchStartX = e.touches[0].clientX;
            }
          });

          touchLayer.addEventListener('touchend', (e) => {
            if (currentMode !== 'progress') return;
            if (touchStartX === null) return;
            if (e.changedTouches.length === 0) return;

            const endX = e.changedTouches[0].clientX;
            const dx   = endX - touchStartX;
            const threshold = 40;
            if (Math.abs(dx) > threshold) {
              const sceneEl = document.querySelector('[progress-showcase]');
              if (!sceneEl) return;
              const comp = sceneEl.components['progress-showcase'];
              if (!comp) return;
              if (dx < 0) comp.next();
              else        comp.prev();
            }
            touchStartX = null;
          });
        }
      });
    </script>
  </head>

  <body>
    <!-- UIオーバーレイ -->
    <div class="overlay">
      <div class="menu-bar">
        <div class="hamburger" id="menuButton">
          <span></span><span></span><span></span>
        </div>
        <div class="menu-title">XR Letter Menu</div>
      </div>
      <div class="menu-panel" id="menuPanel">
        <div class="menu-item active" data-mode="letter">手紙</div>
        <div class="menu-item" data-mode="progress">進捗</div>
      </div>

      <div class="mode-indicator" id="modeIndicator">モード：手紙</div>
    </div>

    <!-- スワイプ検出レイヤー -->
    <div id="touchLayer"></div>

    <!-- ARシーン -->
    <a-scene
      embedded
      renderer="antialias: true; alpha: true"
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; debugUIEnabled: false;">
      <a-assets></a-assets>

      <!-- 共通マーカー -->
      <a-marker preset="hiro" scroll-manager>
        <!-- 手紙ウィンドウ -->
        <a-entity id="letterRoot">
          <a-plane
            color="#ffffff"
            width="2.4"
            height="1.6"
            position="0 0 0.1"
            rotation="0 0 0"
            opacity="0.97">
          </a-plane>
        </a-entity>

        <!-- 進捗ウィンドウ（最初は非表示） -->
        <a-entity id="progressRoot" progress-showcase visible="false">
          <a-plane
            color="#ffffff"
            width="2.4"
            height="1.6"
            position="0 0 0.1"
            rotation="0 0 0"
            opacity="0.97">
          </a-plane>
        </a-entity>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>
  </body>
</html>
