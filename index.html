<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>XR Letter Loading... (Scroll Credits)</title>

    <!-- Zen Kurenaido -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Kurenaido&display=swap" rel="stylesheet">

    <!-- A-Frame / AR.js -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="./js/aframe-ar.js?v=1.0.2"></script>

    <!-- キャッシュ対策 -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .overlay {
        position: fixed;
        z-index: 10;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
      }
    </style>

    <script>
      // ===== 文章 =====
      const firstLineText = "塩田さんへ"; // 最初に中央でフェードイン/アウトする行

      // スクロールで流す部分（空行は "" を入れる）
      const scrollLines = [
        "同じ学科の後輩として、",
        "同じ班の後輩として、",
        "いつも活動できたことが嬉しかったです。",
        "",
        "塩田さんは、",
        "僕にとって憧れの人です。",
        "明るさにも、優しさにも、",
        "全てに惹かれています。",
        "",
        "塩田さんがXR班をつくったことで、",
        "僕はXRという世界に出会いました。",
        "XRに触れた日から、",
        "視界が一気に広がりました。",
        "",
        "今回の理工展で企画を担当できたのも、",
        "塩田さんがいたからです。",
        "",
        "来期は、もっと面白いものを作ります。",
        "胸を張って見せられるものを作ります。",
        "",
        "このAR手紙には、",
        "これからのXR班の進捗を",
        "3Dオブジェクトで追加していこうと思っています。",
        "",
        "よかったら、また覗きに来てください。",
        "その時、少しでも成長したXR班を",
        "見せられますように。",
        "",
        "", "", ""   // ★ ここは最後に大きな空白を作るための空行
      ];

      // 最後に中央で止まる2行
      const finalBlockLines = [
        "本当にありがとうございました。",
        "齋藤旦伍より"
      ];

      // マスク用ウィンドウ（このY範囲だけ表示）
      const WINDOW_MIN_Y = -0.7;
      const WINDOW_MAX_Y =  0.7;

      // スクロール速度など（好みで調整OK）
      const SCROLL_SPEED = 0.18;   // 上方向のスピード（m/s）
      const BASE_START_Y = -1.0;   // 1行目のスタート位置
      const LINE_GAP     = 0.22;   // 行間（小さくすると行が詰まる）

      // 内部状態
      let firstDone = false;      // 「塩田さんへ」が終わったか
      let canvasIdCounter = 0;    // キャンバスID用カウンタ

      // ===== 共通：1行用キャンバス作成（空行も「空白高さ」として扱う） =====
      function createCanvasForText(text) {
        const assets = document.querySelector('a-assets');
        if (!assets) return null;

        const id = `msgCanvas_${canvasIdCounter++}`;
        const canvas = document.createElement('canvas');
        canvas.id = id;

        const width  = 2048;
        const height = 256;
        canvas.width  = width;
        canvas.height = height;

        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, width, height);

        ctx.font = "80px 'Zen Kurenaido', sans-serif";
        ctx.fillStyle = "#000000";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // ★ 空行は文字を描かないが、高さは確保したいので canvas 自体は使う
        if (text.trim() !== "") {
          ctx.fillText(text, width / 2, height / 2);
        }

        assets.appendChild(canvas);
        return { id, width, height };
      }

      // ===== 最初の1行：中央でフェードイン → ホールド → フェードアウト =====
      AFRAME.registerComponent('firstline', {
        schema: {
          fadeIn:  { type: 'number', default: 1.0 },
          hold:    { type: 'number', default: 3.0 },
          fadeOut: { type: 'number', default: 1.0 }
        },

        init: function () {
          this.startTime = null;
        },

        tick: function (time, dt) {
          const el   = this.el;
          const data = this.data;

          if (this.startTime === null) {
            this.startTime = time;
          }

          const t = (time - this.startTime) / 1000;
          const total = data.fadeIn + data.hold + data.fadeOut;
          let alpha = 0;

          if (t < data.fadeIn) {
            alpha = t / data.fadeIn;
          } else if (t < data.fadeIn + data.hold) {
            alpha = 1;
          } else if (t < total) {
            const t2 = t - (data.fadeIn + data.hold);
            alpha = 1 - (t2 / data.fadeOut);
          } else {
            alpha = 0;
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            firstDone = true; // ★ ここからスクロール開始OK
          }

          el.setAttribute('material', 'transparent', true);
          el.setAttribute('material', 'opacity', alpha);
        }
      });

      // ===== スクロール行：上に動かしつつ、白ウィンドウだけ表示 =====
      AFRAME.registerComponent('scrollline', {
        schema: {
          speed:  { type: 'number', default: SCROLL_SPEED },
          startY: { type: 'number', default: BASE_START_Y },
          endY:   { type: 'number', default: 1.4 }
        },

        init: function () {
          const el   = this.el;
          const data = this.data;
          const pos  = el.getAttribute('position') || {x: 0, y: 0, z: 0};
          pos.y = data.startY;
          el.setAttribute('position', pos);
        },

        tick: function (time, dt) {
          const el   = this.el;
          const data = this.data;

          const deltaSec = dt / 1000;
          const pos = el.getAttribute('position');
          pos.y += data.speed * deltaSec;
          el.setAttribute('position', pos);

          const y = pos.y;

          // マスク：白背景の範囲だけ不透明、それ以外は完全に透明
          if (y < WINDOW_MIN_Y || y > WINDOW_MAX_Y) {
            el.setAttribute('material', 'transparent', true);
            el.setAttribute('material', 'opacity', 0.0);
          } else {
            el.setAttribute('material', 'transparent', true);
            el.setAttribute('material', 'opacity', 1.0);
          }

          // かなり上に抜けたら削除
          if (y > data.endY) {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
          }
        }
      });

      // ===== 最後の2行：中央でフェードイン → ホールド → フェードアウト =====
      AFRAME.registerComponent('finalblock', {
        schema: {
          fadeIn:  { type: 'number', default: 1.0 },
          hold:    { type: 'number', default: 3.0 },
          fadeOut: { type: 'number', default: 1.0 }
        },

        init: function () {
          this.startTime = null;
        },

        tick: function (time, dt) {
          const el   = this.el;
          const data = this.data;

          if (this.startTime === null) {
            this.startTime = time;
          }

          const t = (time - this.startTime) / 1000;
          const total = data.fadeIn + data.hold + data.fadeOut;
          let alpha = 0;

          if (t < data.fadeIn) {
            alpha = t / data.fadeIn;
          } else if (t < data.fadeIn + data.hold) {
            alpha = 1;
          } else if (t < total) {
            const t2 = t - (data.fadeIn + data.hold);
            alpha = 1 - (t2 / data.fadeOut);
          } else {
            alpha = 0;
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
          }

          el.setAttribute('material', 'transparent', true);
          el.setAttribute('material', 'opacity', alpha);
        }
      });

      // ===== Manager：最初 → スクロール → 最後の2行 =====
      AFRAME.registerComponent('scroll-manager', {
        init: function () {
          this.scrollBuilt = false;
          this.finalScheduled = false;

          // 1) 最初の「塩田さんへ」
          const marker = this.el;
          const tex = createCanvasForText(firstLineText);
          if (!tex) return;

          const plane = document.createElement('a-plane');
          plane.setAttribute(
            'material',
            `src: #${tex.id}; transparent: true; side: double`
          );

          const planeWidth  = 2.2;
          const aspect      = tex.height / tex.width;
          const planeHeight = planeWidth * aspect;

          plane.setAttribute('width',  planeWidth);
          plane.setAttribute('height', planeHeight);
          plane.setAttribute('position', '0 0 0.12');
          plane.setAttribute('rotation', '0 0 0');
          plane.setAttribute('firstline', 'fadeIn: 1.0; hold: 3.0; fadeOut: 1.0');

          marker.appendChild(plane);
        },

        tick: function (time, dt) {
          const marker = this.el;

          // 最初の行が終わるまで待機
          if (!firstDone) return;

          // 2) スクロール行を組み立て（1回だけ）
          if (!this.scrollBuilt) {
            this.buildScrollLines();
            this.scrollBuilt = true;
          }

          // 3) 最後のブロックを出すタイミングをまだセットしていなければ計算して予約
          if (this.scrollBuilt && !this.finalScheduled) {
            this.scheduleFinalBlock();
            this.finalScheduled = true;
          }
        },

        buildScrollLines: function () {
          const marker = this.el;

          for (let i = 0; i < scrollLines.length; i++) {
            const text = scrollLines[i];
            const tex = createCanvasForText(text);
            if (!tex) continue;

            const plane = document.createElement('a-plane');
            plane.setAttribute(
              'material',
              `src: #${tex.id}; transparent: true; side: double`
            );

            const planeWidth  = 2.2;
            const aspect      = tex.height / tex.width;
            const planeHeight = planeWidth * aspect;

            plane.setAttribute('width',  planeWidth);
            plane.setAttribute('height', planeHeight);
            plane.setAttribute('position', `0 0 0.12`);
            plane.setAttribute('rotation', '0 0 0');

            // 下方向に等間隔で並べておき、一斉に上に流す
            const startY = BASE_START_Y - i * LINE_GAP;
            plane.setAttribute(
              'scrollline',
              `speed: ${SCROLL_SPEED}; startY: ${startY}; endY: 1.4`
            );

            marker.appendChild(plane);
          }
        },

        // スクロールがだいたい終わった頃に最後のブロックを出す
        scheduleFinalBlock: function () {
          const marker = this.el;

          const lastIndex = scrollLines.length - 1;
          const lastStartY = BASE_START_Y - lastIndex * LINE_GAP;

          // 「最後の行がウィンドウ上端を通過するまで」の時間をざっくり計算
          const dist = WINDOW_MAX_Y - lastStartY;
          const scrollTime = dist / SCROLL_SPEED;

          const margin = -3.0; 
          const delayMs = (scrollTime + margin) * 1000;

          setTimeout(() => {
            // 最後の2行を1枚のキャンバスとして描画
            const assets = document.querySelector('a-assets');
            if (!assets) return;

            const id = `finalCanvas`;
            const canvas = document.createElement('canvas');
            canvas.id = id;
            const width  = 2048;
            const height = 512;
            canvas.width  = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, width, height);

            ctx.font = "80px 'Zen Kurenaido', sans-serif";
            ctx.fillStyle = "#000000";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // 2行で中央寄せ
            const line1 = finalBlockLines[0];
            const line2 = finalBlockLines[1];
            ctx.fillText(line1, width / 2, height / 2 - 60);
            ctx.fillText(line2, width / 2, height / 2 + 60);

            assets.appendChild(canvas);

            const plane = document.createElement('a-plane');
            plane.setAttribute(
              'material',
              `src: #${id}; transparent: true; side: double`
            );

            const planeWidth  = 2.2;
            const aspect      = height / width;
            const planeHeight = planeWidth * aspect;

            plane.setAttribute('width',  planeWidth);
            plane.setAttribute('height', planeHeight);
            plane.setAttribute('position', '0 0 0.13'); // 中央
            plane.setAttribute('rotation', '0 0 0');
            plane.setAttribute('finalblock', 'fadeIn: 1.0; hold: 3.0; fadeOut: 1.5');

            marker.appendChild(plane);
          }, delayMs);
        }
      });
    </script>
  </head>

  <body>
    <div class="overlay">XR Letter Loading... (Scroll Credits)</div>

    <a-scene
      embedded
      renderer="antialias: true; alpha: true"
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; debugUIEnabled: false;"
    >
      <!-- JS 側で行ごとに canvas を追加していく -->
      <a-assets></a-assets>

      <!-- Hiro マーカー -->
      <a-marker preset="hiro" scroll-manager>
        <!-- 常に表示される白い縦長背景 -->
        <a-plane
          color="#ffffff"
          width="2.4"
          height="1.6"
          position="0 0 0.1"
          rotation="0 0 0"
          opacity="0.97"
        ></a-plane>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>
  </body>
</html>
