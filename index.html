<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>XR Letter - Scroll Credits</title>

    <!-- Zen Kurenaido -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Kurenaido&display=swap" rel="stylesheet">

    <!-- A-Frame / AR.js -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="./js/aframe-ar.js?v=1.0.2"></script>

    <!-- キャッシュ対策 -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .overlay {
        position: fixed;
        z-index: 10;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
      }
    </style>

    <script>
      // ===== 表示する文章（1行ごと） =====
      const messages = [
        "塩田さんへ",  // 0: 最初の演出専用

        "同じ学科の後輩として、",
        "同じ班の後輩として、",
        "いつも活動できたことが嬉しかったです。",

        "塩田さんは、",
        "僕にとって憧れの人です。",
        "明るさにも、優しさにも、",
        "全てに惹かれています。",

        "塩田さんがXR班をつくったことで、",
        "僕はXRという世界に出会いました。",
        "XRに触れた日から、",
        "視界が一気に広がりました。",

        "今回の理工展で企画を担当できたのも、",
        "塩田さんがいたからです。",

        "来期は、もっと面白いものを作ります。",
        "胸を張って見せられるものを作ります。",

        "このAR手紙には、",
        "これからの僕の進捗を、",
        "3Dオブジェクトで追加していこうと思っています。",

        "よかったら、また覗きに来てください。",
        "その時、少しでも成長した僕を",
        "見せられますように。",

        "本当にありがとうございました。"
      ];

      // 「塩田さんへ」が終わったかどうか
      let firstDone = false;

      // 白帯の“窓”範囲（この中だけ表示）
      const WINDOW_MIN_Y = -0.6;
      const WINDOW_MAX_Y =  0.6;

      // 共通：1行分のテキストをキャンバスに描く
      function drawLineToCanvas(text) {
        const canvas = document.getElementById('msgCanvas');
        if (!canvas) return null;

        const ctx = canvas.getContext('2d');
        const width = 2048;
        const height = 256;

        canvas.width  = width;
        canvas.height = height;

        ctx.clearRect(0, 0, width, height);
        ctx.font = "80px 'Zen Kurenaido', sans-serif";
        ctx.fillStyle = "#000000";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.fillText(text, width / 2, height / 2);

        return canvas;
      }

      // ===== 最初の1行「塩田さんへ」：中央でフェードイン/アウト =====
      AFRAME.registerComponent('firstline', {
        schema: {
          fadeIn:  { type: 'number', default: 1.0 },
          hold:    { type: 'number', default: 3.0 },
          fadeOut: { type: 'number', default: 1.0 }
        },

        init: function () {
          this.startTime = null;
        },

        tick: function (time, dt) {
          const el = this.el;
          const data = this.data;

          if (this.startTime === null) {
            this.startTime = time;
          }

          const t = (time - this.startTime) / 1000; // 秒
          const total = data.fadeIn + data.hold + data.fadeOut;
          let alpha = 0;

          if (t < data.fadeIn) {
            alpha = t / data.fadeIn;
          } else if (t < data.fadeIn + data.hold) {
            alpha = 1;
          } else if (t < total) {
            const t2 = t - (data.fadeIn + data.hold);
            alpha = 1 - (t2 / data.fadeOut);
          } else {
            alpha = 0;
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            firstDone = true; // ★ ここからスクロール開始OK
          }

          el.setAttribute('material', 'transparent', true);
          el.setAttribute('material', 'opacity', alpha);
        }
      });

      // ===== 各行を上に流すコンポーネント（全行同じ速度） =====
      AFRAME.registerComponent('scrollline', {
        schema: {
          speed:   { type: 'number', default: 0.22 },
          startY:  { type: 'number', default: -1.0 },
          endY:    { type: 'number', default:  1.2 }
        },

        init: function () {
          const el   = this.el;
          const data = this.data;
          const pos  = el.getAttribute('position') || {x: 0, y: 0, z: 0};
          pos.y = data.startY;
          el.setAttribute('position', pos);
        },

        tick: function (time, dt) {
          const el   = this.el;
          const data = this.data;

          const deltaSec = dt / 1000;
          const pos = el.getAttribute('position');
          pos.y += data.speed * deltaSec;     // 上方向へ
          el.setAttribute('position', pos);

          const y = pos.y;

          // ★ 白背景の窓の中だけ表示、それ以外は非表示（マスク風）
          if (y < WINDOW_MIN_Y || y > WINDOW_MAX_Y) {
            el.setAttribute('material', 'transparent', true);
            el.setAttribute('material', 'opacity', 0.0);
          } else {
            el.setAttribute('material', 'transparent', true);
            el.setAttribute('material', 'opacity', 1.0);
          }

          // かなり上に抜けたら削除
          if (y > data.endY) {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
          }
        }
      });

      // ===== Manager：最初の1行 → その後、全行を“下に並べて”一気に流す =====
      AFRAME.registerComponent('scroll-manager', {
        init: function () {
          this.built = false;

          // まず「塩田さんへ」を中央に表示
          const marker = this.el;
          const canvas = drawLineToCanvas(messages[0]);
          if (!canvas) return;

          const plane = document.createElement('a-plane');
          plane.setAttribute(
            'material',
            'src: #msgCanvas; transparent: true; side: double'
          );

          const planeWidth  = 2.2;
          const aspect      = canvas.height / canvas.width; // 256 / 2048
          const planeHeight = planeWidth * aspect;

          plane.setAttribute('width',  planeWidth);
          plane.setAttribute('height', planeHeight);
          plane.setAttribute('position', '0 0 0.12'); // 白背景中央
          plane.setAttribute('rotation', '0 0 0');
          plane.setAttribute('firstline', 'fadeIn: 1.0; hold: 3.0; fadeOut: 1.0');

          marker.appendChild(plane);
        },

        tick: function (time, dt) {
          // 「塩田さんへ」が終わるまで待つ
          if (!firstDone) return;
          if (this.built) return;

          this.buildScrollLines();
          this.built = true;
        },

        buildScrollLines: function () {
          const marker = this.el;
          const baseStartY = -1.0;  // 1行目が出てくる位置
          const gap       = 0.22;   // 下に並べる間隔（値をいじると行間が変わる）
          const speed     = 0.22;   // 上方向の速度（約10秒で画面を通過）

          for (let i = 1; i < messages.length; i++) {
            const text = messages[i];
            const canvas = drawLineToCanvas(text);
            if (!canvas) continue;

            const plane = document.createElement('a-plane');
            plane.setAttribute(
              'material',
              'src: #msgCanvas; transparent: true; side: double'
            );

            const planeWidth  = 2.2;
            const aspect      = canvas.height / canvas.width;
            const planeHeight = planeWidth * aspect;

            plane.setAttribute('width',  planeWidth);
            plane.setAttribute('height', planeHeight);
            plane.setAttribute('position', `0 0 0.12`);
            plane.setAttribute('rotation', '0 0 0');

            const startY = baseStartY - (i - 1) * gap; // 全行を下に並べる
            plane.setAttribute(
              'scrollline',
              `speed: ${speed}; startY: ${startY}; endY: 1.4`
            );

            marker.appendChild(plane);
          }
        }
      });
    </script>
  </head>

  <body>
    <div class="overlay">XR Letter Loading... (Scroll Credits)</div>

    <a-scene
      embedded
      renderer="antialias: true; alpha: true"
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; debugUIEnabled: false;"
    >
      <a-assets>
        <canvas id="msgCanvas"></canvas>
      </a-assets>

      <!-- Hiro マーカー -->
      <a-marker preset="hiro" scroll-manager>
        <!-- ★ 常に表示される白い縦長背景（窓） -->
        <a-plane
          color="#ffffff"
          width="2.4"
          height="1.6"
          position="0 0 0.1"
          rotation="0 0 0"
          opacity="0.97"
        ></a-plane>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>
  </body>
</html>
